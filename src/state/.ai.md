# State Management Reference

## Import Rules (IMPORTANT)
- **External imports must use index.ts only**
  - ‚úÖ `import { useProduct, type Product } from '@/state/product'`
  - ‚ùå `import { useProduct } from '@/state/product/store'`
  - ‚ùå `import type { Product } from '@/state/product/types'`
- Within same domain folder, relative imports are allowed
- ESLint `index-only-import` rule enforces this

## Structure
**Standard structure for all state domains:**

```
src/state/{domain}/
  ‚îú‚îÄ‚îÄ types.ts         # State, Actions, API types
  ‚îú‚îÄ‚îÄ store.ts         # createStateFactory + compose actions
  ‚îú‚îÄ‚îÄ index.ts         # Export (add DI wrapper if needed)
  ‚îî‚îÄ‚îÄ actions/
      ‚îú‚îÄ‚îÄ init.ts      # SSR initialization (if needed)
      ‚îî‚îÄ‚îÄ *.ts         # Group by feature (e.g., comment.ts, like.ts)
```

## Rules
- **Always use `@/lib/state`** - Import `createStateFactory` and types from `@/lib/state`, never import Zustand directly
- **Use `@/api`** - All data fetching and mutations go through `@/api`
- **Cache data** - Check if data exists in state before making API calls
- **Optimistic updates** - Update UI immediately, rollback on error
- **Sync list and detail** - When updating detail, also update the corresponding item in list
  - Example: Like detail ‚Üí Update `detail.likeCount` AND `items.find(id).likeCount`
- **SSR initialization** - Use `{ silent: true }` when initializing state from server data to prevent hydration mismatch

### store.ts
```typescript
import { createStateFactory } from '@/lib/state'
import type { ProductState, ProductActions } from './types'
import { createInitActions } from './actions/init'
import { createCommentActions } from './actions/comment'
import { createLikeActions } from './actions/like'

export const [useProduct, useProductContext] = createStateFactory<
  ProductState,
  ProductActions
>({
  initialize: () => ({
    items: [],
    current: null,
    isLoading: false
  }),
  
  actions: (set, get, context) => ({
    ...createInitActions(set, get, context),
    ...createCommentActions(set, get, context),
    ...createLikeActions(set, get, context)
  })
})
```

### types.ts
```typescript
import type { Product as APIProduct } from '@/api'

// Re-export API types, extend with UI state if needed
export type Product = APIProduct & { isOptimistic?: boolean }

export type ProductState = {
  items: Product[]
  current: Product | null
  isLoading: boolean
}

export type ProductActions = {
  init: (product: Product) => void
  addComment: (content: string) => Promise<void>
  likeProduct: (id: string) => Promise<void>
}

// If cross-domain deps needed, define Internal type:
export type InternalProductActions = Omit<ProductActions, 'addComment'> & {
  addComment: (content: string, getUser: () => User | null) => Promise<void>
}
```

### actions/*.ts
```typescript
// actions/comment.ts
import type { StateSetFn, StateGetFn, StateContext } from '@/lib/state/types'
import type { ProductState, ProductActions } from '../types'

type CommentActions = Pick<ProductActions, 'addComment'>

export const createCommentActions = (
  set: StateSetFn<ProductState>,
  get: StateGetFn<ProductState>,
  context: StateContext
): CommentActions => ({
  addComment: async (content) => {
    const comment = await api.product.addComment(get().current.id, content)
    set(state => { state.current.comments.push(comment) })
  }
})
```

### index.ts
```typescript
'use client'

// 1. Simple re-export if no wrapper needed:
export * from './types'
export { useProduct, useProductContext } from './store'

// 2. Type-safe wrapper with generic selector (selector required):
import type { StateWithActions } from '@/lib/state/types'
import { useProduct as _useProduct } from './store'
import type { ProductState, ProductActions } from './types'

export function useProduct<TResult>(
  selector: (state: StateWithActions<ProductState, ProductActions>) => TResult
): TResult {
  return _useProduct(selector)
}

// 3. With DI wrapper if cross-domain deps needed:
import { useUserContext } from '../user/store'
import { useProduct as _useProduct } from './store'

export function useProduct<TResult>(
  selector: (state: StateWithActions<ProductState, ProductActions>) => TResult
): TResult {
  const getUser = useUserContext()

  return _useProduct(
    selector,
    (actions) => ({
      ...actions,
      addComment: (content) => actions.addComment(content, () => getUser().me)
    })
  )
}
```

## SSR Pattern: Silent Initialization
**Use `{ silent: true }` when initializing from server data**

```typescript
// src/state/user/actions/init.ts
export const createInitActions = (set, get, context) => ({
  init: (user: User | null) => {
    set(
      state => { 
        state.me = user
        state.isAuthenticated = !!user
      },
      { silent: true }  // üîë Prevents re-render during hydration
    )
  }
})

// src/state/user/store.ts
export const [useUser, useUserContext] = createStateFactory<...>({
  initialize: () => ({ me: null, isAuthenticated: false }),
  actions: (set, get, context) => ({
    ...createInitActions(set, get, context),
    // ... other actions
  })
})

// Usage in App
// Server Component: Fetch user
const user = await getUserSession()

// Client Component: Initialize state
'use client'
const init = useUser(s => s.actions.init)
init(user)  // silent: true prevents hydration mismatch
```

## Key Concepts

- **createStateFactory** - Zustand wrapper with Immer (from `@/lib/state`)
- **silent: true** - Prevents re-render during SSR initialization
- **StateSetFn, StateGetFn, StateContext** - Types from `@/lib/state/types`
- **Dependency Injection** - Use index.ts to inject cross-domain dependencies